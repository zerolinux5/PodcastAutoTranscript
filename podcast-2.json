{"podcast_details": {"podcast_title": "Software Engineering Daily", "episode_title": "The Latest on RedwoodJS with Tom Preston-Werner", "episode_image": "http://softwaredaily.wpengine.com/wp-content/uploads/powerpress/SED_square_solid_bg.png", "episode_transcript": " Tom Preston Warner is a renowned software developer, inventor, and entrepreneur. He co-founded GitHub and is the creator of the avatar service Gravatar, the Toml configuration file format, and the static site generator software Jekyll. Tom is currently working on the full stack web framework, Redwood.js. He joins us today to tell us about the latest about Redwood.js, including its new support for server-side rendering. Check out the show notes for a link to the Redwood.js conference. Powell is a tech lead and a software engineer with a background in launching products in startups and big companies. He's also the founder of Flat Social. Check out the show notes to follow Powell on Twitter or LinkedIn, or visit his personal website, powell.io. Hi Tom, welcome to Software Engineering Daily. Thanks, happy to be here. Great to have you. Do you want to host for Software Engineering Daily? We're growing the podcast and are looking for hosts to cover a wide range of topics including AI, cybersecurity, databases, robotics, game development, VR, and more. Hosting for SCD is a great way to expand your expertise in both established and frontier technologies. So if you have a passion for software and want to host for us, email editor at softwareengineeringdaily.com. So let's dive right in and explain what is Redwood.js? Redwood.js is a full stack JavaScript and TypeScript framework for building web applications using modern technologies. It's a more opinionated, sort of more complete web application framework. So we try to build in everything that you need in order to really build a sophisticated SaaS application using React, GraphQL, Prisma, and kind of everything that goes along with that, testing, storybook. Try to include everything that you need to get started and to maintain it long term. And how did you get into programming at what were your first steps in the software industry? So where did it all start? I guess I really first started programming when I was maybe 10 years old. My dad had bought a TRS-80 computer. It had no real operating system. It would boot to basically a prompt and then you would write a program with Basic. So you kind of had to tell it everything that you wanted it to do. And I loved it. I loved writing programs in by hand, copying in programs from magazines that I would find. And I just really loved the wins that you get from making the computer do something that you want it to do and being successful and overcoming all of the inevitable bugs and missing syntax that you do when you're a kid. But I just, I really love that feeling of success over and over. Like you get something working and then you have an idea and you can implement it and see that success right away. That's how I got started. And then I actually thought I was going to be a physicist, theoretical physicist, very into physics, still read a lot of physics. But in college it turned into just math, like pure math, very abstract, pure math. I don't like math, maybe quite that much. And so I pivoted to computers because I'd always done that as a kid growing up in high school and everything and thought that I wanted to be able to affect people's lives more directly. You know, if you're a physicist, you might make an important discovery once in your lifetime or something, you know. It might take you 20 years to get there as a theoretician. But I thought it would be nice to impact people's lives more directly, more often. And computers, as I talked about, are a way to do that, to get to those wins right away. So that pivoted me into computer science and then I got hired as a startup. I dropped out of college to join a startup right during the dot com boom in like 2001. And then a string of random startups that did not very well, brought me to San Francisco eventually, worked on GitHub, started GitHub there and the rest is history. So before RedwoodJS, you have, as you just said, you have a co-founded GitHub. You've also created Gravatar. You have created Toml, which is an acronym for Tom's Obvious Minimal Language. Correct me if I'm wrong. Indeed, that's correct. Also Jekyll and a language learning platform called Chatterbug. And I was wondering what motivates you to start a new project and do you follow any specific process that helps you to decide what are you going to work on next? I think for me, I love creating things. So I always have some project that I'm working on. And in the early days, I was doing some consulting. This is after I got laid off from one of those random startups that wasn't doing very well. I was doing consulting and just laying around in my bed trying to, you know, I stared at the ceiling and I was trying to think of something to do in sort of the blogosphere. And that's where the idea for Gravatar came from. Just an idea that people could use it. It would be useful for them. And I just created it, hacked it up, and it turned out to be something that people wanted. People liked it. And it's always just that. It's always just wanting to contribute. You know, I ended up selling that and that's what freed up my time to work on GitHub actually. I was working a full-time job as well at a startup called PowerSet at the time in San Francisco. It was like a search engine. And then I was working on GitHub on the side. GitHub was a project that I decided needed to be able to make money unlike Gravatar. Gravatar never made me a single cent except when I sold it. But running it, it didn't have a business model. So I wanted whatever my side project was going to be to have a real business model so that if it became successful, then I could actually work on it full time. And so that's why GitHub had a business model built in from the beginning because I wanted, that was sort of a filter criteria for me for new side projects to work on. And so it's always just that. And it's just born out of what needs to exist that doesn't exist yet. What problems do I have that I can see a solution for and then just follow those threads? So right now I have a couple of side projects. I mean, Redwood JS I work on quite a bit with a team. But I'm also working on sort of a social media thing called Spoke. That's sort of a social media for people building things, builders. As well as I have an electronics project. I've been trying to get back into electronics. I used to do that a lot as a kid as well. Getting into microcontrollers, modern day microcontrollers. And so I have a smart speaker controller that you use with NFC cards to activate and play an album. So who knows where those will go? I don't know. Maybe they'll go somewhere and maybe they won't. Just like all of my projects, when we started GitHub, I didn't know if it was going to be a thing. I had no idea that it would become what it has become at all. I thought like this would be cool for my friends and I to use together to share code and work on stuff that looks better and gets better than subversion. So it's always just chasing threads, interesting threads, following curiosity. That's really what it's born of. Every project. And at which point with GitHub did you know, like because you said like in the beginning you didn't know if it's going to be successful or not. You just built it mostly for yourself and the friends and other people that wanted to use it. At which point did you know that I'm onto something and that this is going to be big? I think we started to have a sense of that fairly early. We were really deep into the Ruby community in San Francisco. At the time this is like 2007 or so. So we'd go to Ruby meetups and we'd start showing early versions of it to people and people really liked it. I mean subversion for any of you out there that have experience with subversion. Subversion was not delightful, let's say. Lots of problems and seeing something with a better branching and merging model was pretty eye-opening for people. But I think we really knew once we had the early version through the first version that we released after about six months of working on it. And then we started charging for it. We sort of opened up the, we had a private beta and then we opened it up for people, public beta, and started charging for it and people started paying for it right away. People were like, people were begging to pay for it even before we, before you could pay for it because they wanted it to exist. They wanted more of what it already was. And that I think is an amazing sign when people are reaching out to you saying, hey, can I pay for this because I'm going to use this for my business and I want to make sure that I have support and that this is going to exist over the long term. That was pretty obvious at that point. And then it just started growing. And so we had very strong confidence that we were onto something. Excel. And why did you start working on Redwood.js? And did you take, when sketching out the initial features or the shape of Redwood.js, did you take any inspiration from any other frameworks or any other languages? Absolutely. Yeah, really it comes from my background in Ruby on Rails. So I love Rails. That's really where, I mean, that's why GitHub is written in Rails. We were part of that community. Everyone I knew was doing Ruby, Ruby on Rails. I loved it. It's amazing. It's still amazing. But it comes out of really two separate threads. One thread is I've been involved in Netlify, the hosting company for a long time, sort of an early investor, an angel investor in their first round. And I was with those guys in the dog patch when they were first starting. And that really came out of my work with Jekyll, the static site generator. And so Netlify was doing static site hosting, you know, plus more. But that's why I got involved. And as they brought more features into Netlify, and especially when they brought in really easy to use Lambda functions, so you could just write a Lambda function, put it in a specific directory, push it up to Netlify. And now you'd get your static hosting, but you'd get your Lambda functions for free, essentially. Like you just put them in a directory and push them up. Using AWS's tools, it was kind of annoying. You had to like create a zip file and push them somewhere and there was no control. It's like, how do you keep track of this over time? Just not much good tooling to make that happen. A lot of friction. And so I was thinking later on, and this is during Chattery, while I was working at Chatterbug. So that's just sort of one thread. I thought it would be cool to create a framework that would leverage that set of technologies in the back of my mind, always. Right. Meanwhile, at Chatterbug, we're building Chatterbug language learning software with Rails, we're using React on the front end, and then we build a mobile client. And for the mobile client, we start using GraphQL. And so the mobile client consumes just GraphQL. And once we had a sophisticated GraphQL backend, API, then we started consuming that GraphQL API from the front end. Because if you have a GraphQL API, it's really a joy to consume and use as a front end developer. So front end developers loved using GraphQL. And so now we started using less and less Rails. It was really sort of the GraphQL Ruby API and React consuming the GraphQL directly. And Rails wasn't doing much anymore. And so I started thinking, why are we using Ruby at all if we're writing React in JavaScript? Why aren't we writing the backend in JavaScript as well? And there's a lot of tooling around, you know, GraphQL, JavaScript GraphQL libraries that were really great. But there was nothing that looked like Rails, like a framework that was all put together and integrated nicely. And I thought that was a place that could use improvement. Everyone was using sort of disparate tools. Everyone was integrating, doing their own integrations, and kind of doing them badly because that's not what you really want to spend your time doing when you're building a company. You want to get to work writing the business logic, the interesting useful stuff of your company, not figure out how to integrate Jest testing with Prisma. Like that's just not a good use of time. And coming from the Rails world, it seemed ridiculous to me that there wasn't sort of a corollary to Rails in the JavaScript and TypeScript world. And so that was the beginning of that idea. And so I combined these two ideas, like how could I build this framework that made it possible to create a full stack web application and deploy it on Netlify using lambdas and sort of the CDN delivery jam stack principles. And hey, here's React and sort of React and GraphQL based framework that could fit that model. Where now you're delivering your React application, SPA, statically via CDN to the browser. And then you run your GraphQL API on lambdas that can be deployed around the world. And you still have to solve for the database part. So that was sort of an exercise to be completed. But the basic architecture seemed like it would work in a jam stack architecture. So we've deviated from that now. We could talk about that later, how Redwood.js has evolved over time. But that's where we started, right? We have nothing to do with jam stack anymore. It's not jam stack specific. We do a lot of things with servers. You can deploy to AWS, et cetera. But at the time, those were the problems that I was trying to solve. So that was kind of the impetus for Redwood.js to exist in the first place. And what do you think as a full stack application developer, right, within the JavaScript world? What do you think are the biggest challenges for developers that come in and they try to start building an application at the moment? I think choice is very challenging now. Maybe not some of the simple choices. Like, it's very easy to reach for Next.js because it's a simple framework. You can go from nothing to something deployed, some kind of web application deployed on the internet, especially with Vercel. They make it really easy. You can do that very, very quickly. And so that choice, I think, is easy. The harder choices come later once you decide that, hey, I need to actually do testing now, or wouldn't it be nice to host my own database, and what am I going to use to consume it? And how am I going to, maybe I need a mobile client at some point in the future. What kind of API am I going to use? Should I use GraphQL? Should I use REST? Should I use Jest? Should I use vTests? Like, I've got to figure out my bundling situation now to make these things work together. So am I using Vercel's stuff because that's where I'm going to deploy, but what if I don't want to be locked in? Then maybe I should use something else and do my own thing, get off of Next completely, and build my own framework. This is often how it goes in the JavaScript and TypeScript world. There is an inclination to just bolt things together, and I'm not sure why that is. I think it just comes out of the general history of JavaScript and TypeScript, that they've had such a long evolutionary history, but that Node.js is really not super old and mature, and that we've all been sort of discovering things together. There's the Cambrian explosion of possibilities that have been happening, and JavaScript is so popular, and technology is moving so quickly, there's so many different ways that you could do things that it's hard to settle down and say, all right, let's package these things up together. But I think that we have reached a moment in time where that becomes very valuable, that that reuse, that that reuse of knowledge across projects and even across companies, and that was something really nice with Rails, too, is that if you know how to work on a Rails project, you sort of know how to work on any Rails project in its basic form. Of course, you're going to have differences between applications depending on what you're doing, but you know the basics of what it means to work on a Rails app. In today's world of, or commonly how people were building things, you'd have something like Next, and sure, if you know how to use Next, you know how to use Next, but Next is just a very small vertical section of what a web application needs to be, and then you end up bolting on huge amounts of random stuff, randomly arbitrarily chosen things, and so every next application looks very different from each other because you're sort of choosing from the very large grab bag of excellent possibilities. Like, there's a lot of great software out there, but at some point you might want to just choose a set of technologies and know how to use it and solve your problem that way so that you can go from company to company and just solve problems instead of always jumping to newer and newer technologies and never really know what anything is doing. So I was always comparing the JavaScript kind of the landscape into more like a zoo where you enter, and there's like each single animal is completely different. And I also don't, so I didn't do much Ruby and Rails programming, I don't have much experience with Rails, but I worked with Swift and with iOS development quite a lot in the past. And over there, like, went in the Apple world and just do as Apple does, and most of the problems and the decisions were solved before. There was very little wiggle room, you could just go straight in and focus on what you're actually building. When I came back to JavaScript world, it was rather stressful, and I still, when I freelance or contract and I move between projects, I always think that, okay, within the next project, somebody might be using completely different testing library, completely different ORM for the database, they might have completely different patterns on the front end, they might use React, they might use Vue, they might use, you know, there's just so many possibilities that even as a JavaScript developer, even moving between projects is already, you know, and there's a learning curve, sometimes, and before you get up to speed. So I do kind of understand this kind of, it's great to have those choices, but, you know. Right, choice is good, but too much choice can be paralyzing, and I think that we see some of that. It's just, I imagine trying to come in and be a JavaScript developer today as a young person, and the amount of choice that is possible there, you know, this is the exact opposite from when I got started. When I was started, there was one thing I could do, and that was write programs in BASIC. And so that's what I did. I didn't stress about anything. I just learned how to program. And that kind of choiceless thing can be powerful, because you just do it. You have no choice. So you just go. Yeah, you just get to it. So pluses and minuses, like in technology, it's always pluses and minuses. And as a developer, if I would be entering this entire zoo of possibilities and, you know, all the technologies that I could choose, why would I choose Redwood.js for my next project? I think if you want to build a web application, if you're serious about building something, this is today, and we'll talk about the future of Redwood, where we maybe make it easier to get started on random projects with Redwood. But today, with the setup that Redwood.js has, if you're going to build a real project and you want long-term maintainability and you like the idea that you're going to have a framework that provides a lot of great integrations for you, so things like Storybook. I think Storybook and the ability to create React components in isolation and sort of, as you're developing them, build them and be able to put them into any state that you want so that you can see every possible state that your component can be in. Trying to do that inside your application can be quite challenging, especially over time as your application gets more complicated. Being able to use Storybook to help you do that is amazing and I think one of the most undersold amazingnesses of React, if you use React like you have that available to you. But something as simple as integrating Storybook with your application, if you're doing that from scratch, if you start with Next or whatever and then you want to integrate Storybook, you're spending some amount of time doing that. And depending on how well it goes, and sometimes it goes better than other times, depending on your setup and how complicated it is, if you're doing anything weird, that could take you anywhere from a day to a week or two weeks, right? Like getting testing integrated into your application, especially if you want to do things like mocking out your, kind of the API from your front end to your back end, things like that. Those are really time consuming. And you end up needing to do them eventually. And so you might choose Redwood.js because you've done this before. You've built a web application before. You know that there's a lot of challenges there. And how much time you spend working on the framework versus working on your application code. And so with Redwood.js, we as the Redwood team spend a lot of time doing all of that work that you would otherwise end up doing yourself. And so we have beautiful integrations between GraphQL and the Jest testing, and Storybook, and Prisma, and generators to help you build out your pages and work through the boilerplate that otherwise you don't have something to help you do. And the ability to customize those things. You know, we've been doing Redwood.js now for three, almost four years. There's a lot of tooling there, a lot of sophistication, a lot of people that have been down these roads that can help with patterns that all apply into the Redwood.js world. And so really it's about building together an access to a community of people that have been there before and probably hit some of the challenges that you're going to have in a similar way. Things like where should I deploy my app to? Like if I have these specific characteristics, how should I upload photos somewhere? We have developed so many patterns around building web applications that are going to make it easier. If you like the basic set of components that we use right now, if you like GraphQL, if you like Prisma, if you like JavaScript TypeScript, if you like React, if those are technologies that you gravitate towards, then I think you're really, really going to like Redwood.js. And even if you don't, even if you're not super familiar with GraphQL, Redwood is probably the best and easiest way to learn GraphQL and get comfortable with it because we make it so easy to create your GraphQL API backend and deal with tricky things like authentication and permissions and security. Those are things that if you're doing those on your own, you're going to spend a long time getting that right. And recently I've released a new version of Redwood.js. It's called Big Horn, right? It's called Big Horn and you have announced that you are going full on on React server components. So I was wondering if you could maybe explain a little bit what are React server components and how does Redwood.js use them? Yeah, so this is not actually released yet. We've announced the next big epoch of Redwood.js. So the current epoch covers versions 1 through 6. We're on version 6 right now. We didn't just release version 6, which has some really great stuff. Big Horn is going to be probably version 7 or 8, I'm guessing. It's not quite there yet. But we wanted to give people a preview of where we were going. And that is exactly as you said, React server components. So React server components are a new way to think about your React components. So traditionally, React components are executing on the browser, on the client. You deliver down some JavaScript to the browser that contain your React components and then the browser executes those and you might do some data fetching client side to pull down data and make that available to the components. The challenges there are you have performance issues. And so because you're transferring down a lot of JavaScript, you have to wait for that to happen. You have to execute that JavaScript. And then there's challenges around things like OpenGraph tags, so OG tags. If you want to unfurl something on Twitter, for instance, and you have a pure single page application, SPA, React application, then your index page is just a blank page with some JavaScript, with a JavaScript tag on it and no actual content, no place to put meta information like OG tag information. Also can be challenging for SEO, search engine optimization. Google is going to pull that page, it's going to have no content on it, and Google is going to have to execute the JavaScript on that page in order to get the content, and they don't like doing that, so they'll penalize you for that. So you want to be able to deliver more static information to the client. And the way that we have solved this before is doing some server-side rendering and then using hydration on the client side. So you actually do rendering, you can render the page server-side, and then you deliver HTML to the client, but at the same time, you're also delivering that same JavaScript that you would that represents the page, like the whole page, everything on the page. And the client will download that, so the client can show the static version very quickly that was server-rendered, and then rehydrate it by executing the JavaScript and essentially replacing everything on the page with the sort of dynamically generated stuff that is rendering client-side using your React components. And now you have that same React page that you would have even without server-side rendering. So that's one way that you can solve for these problems and deliver real HTML to the client with the first page load. And this is, I think frameworks like Next have been doing this for a long time. So the React team themselves are looking at some of these problems and these patterns that people are using and wondering how they can improve React to make those patterns a little more first class and more flexible. And so React server components are a type of React component that is intended to render on the server and then be able to make that, the use of React components and this kind of idea of hydration a little easier, because you really don't need to rehydrate parts of the page that are always going to be static. And so that's the idea with a React server component, is that something in a React server component really is always going to be static. It's not really intended to change. If you want something to be interactive and changeable, then you have your React server components, those get rendered server-side and sent down as static HTML to the browser. And then nested within those at some point in the sort of the leaves of the tree of React components, you'll have then client components and you say, you tell your framework which of your components are intended to be client components. And those will then be sent down as, well, they will actually be rendered server-side first, if you allow it and there are ways to tell your framework to not render those. But generally, the server is going to attempt to server render even your client components, send down that content, and then the browser will rehydrate just those client components. So it's not sending down JavaScript for components that don't need to change in the browser. So it's being more efficient about the hydration process, essentially. Here's a puzzle. What do products like Dropbox, Slack, Zoom, and Asana all have in common? The answer is that they were all successful because they became enterprise-ready. Becoming enterprise-ready means adding security and compliance features required by enterprise IT admins. When you add these features, enterprises can buy your product and they'll buy a lot. These features unlock larger deals and faster growth. But enterprise features are super complex to build with lots of weird edge cases, and typically they require months or years of precious engineering time. Thankfully, now there's a better solution. WorkOS is a developer platform to make your app enterprise-ready. With a few simple APIs, you can immediately add common enterprise features like single sign-on, OAuth, SAML authentication, and SCIM user provisioning. Developers will find beautiful docs and SDKs that make integration a breeze. WorkOS is kind of like Stripe for enterprise features. Today, WorkOS powers apps like Webflow, Vercell, and more than 300 others. The platform is rock solid, fully SOC 2 compliant, and ready for even the largest enterprise environments. So what are you waiting for? Integrate WorkOS today and make your app enterprise-ready. To learn more and get started, go to WorkOS.com. Hi, I'm Vijay Raji, and I'm the founder and CEO of StatSig. StatSig is a feature management and experimentation framework that is used by companies like Notion, Atlassian, Microsoft, OpenAI, and more to build and release new features to their customers, all the while keeping track of the metrics that matter the most. I started my career as a software engineer, and if you're listening to this podcast, I know that building new and cool products is in your DNA, and you want to ship good, reliable code as fast and as often as possible. The best way to do that is to decouple your feature releases from your code commits. You can do that with the help of feature flags. And this is why at StatSig, we made our feature management package free for builders like you. And we also made our product fully self-serve with open source libraries that you can pick up today and get started. So head on over to statzig.com slash software daily and start building. So would it be that, for example, within and just if I understand it correctly. So, for example, within the server side rendering, the website would serve the HTML, but then it would be hydrated with the JavaScript code that's inside. And with React server components, it's only the parts would be hydrated that really need to be hydrated. And then the rest is already rendered on the server side. Essentially, yes. And along with this comes streaming as well. So streaming and suspense. So suspense has been something that we've waited for a long time in React, and suspense is now a real thing that you can use. The cool thing about suspense and streaming is if you put a suspense tag around a chunk of your code that you want to deliver to the browser because you're going to do some data fetching within something that's inside the suspense boundary, you can still have that execute server side. So let's say you have a server component that needs to do some kind of data fetching that's going to take two seconds. You want to be able to ship down most of the page without waiting for that piece of data, but you don't want it to be executed from the client. You don't want the browser to have to do that data fetching. You'd still want to do that data fetching on the server. And so you can have a React server component and put a suspense boundary around it. And if you're using React server components in streaming, then the server will skip over where your suspense boundary is. It'll render as much of the page as it can without the stuff that's inside your suspense boundary. It'll ship that down. That's your initial page load. But it keeps the connection open. And when the content of that server component that is within that suspense boundary, when that completes and renders, that will use that same connection that's still open, and it will send down the rest of the content that is from inside that suspense boundary. And React knows how to receive that and then insert that into the page in the correct location to complete the content that was within that suspense boundary. So you can do some really nice things for usability, things that make a page feel like it loads much faster. And you can do it on your own terms. And so we're leveraging a lot of these things to kind of do some of the things that we already do in Redwood. We have this pattern called cells for data fetching, client-side data fetching using GraphQL, that we will adapt to use React server components instead. And you'll have the choice of doing something like that on the server side and even doing GraphQL fetching all server side, where you're still using GraphQL if you have a GraphQL API, but you won't need it anymore. So I'd love to talk as well more about that if you're ready for me to dive into some of that. Absolutely. Yes. So this is what the React server components, I still think it's quite a new technology. So we're still adapting to it. Just in general, do you see any limitations for React server components? Did you see any parts of it that you didn't like or didn't agree with? There's always challenges when you're trying to be able to execute something on the server and the client that you get into trouble because you're using something that might be server only or client only. For instance, if you want to read the, get access to the headers of the request, for instance, that's something that the server can easily do, but that doesn't really make sense to the browser. And so you have to be very careful what you're doing in your components so that they can execute in the correct context and hopefully execute in both. So you spend more time, I think, thinking about execution contexts than I really prefer. It's just, it's an additional complication. Like it allows for these really nice and very efficient systems to work, but you can get yourself in trouble where you don't realize that you're using something that is, say, a client specific API. And then the server is trying to execute your component server side to be able to generate your first static page. And now it has to complain to you that, hey, you can't use this. And then you're like, oh, you're right. For example, if you use a window, like a reference to the window, the local storage and something like this. Yeah, exactly. Exactly. So there's a whole classes of things that won't work in the opposite execution context that you have to think about. Coming from Rails, everything was server side and it was just like, I don't know, you didn't think about any of that. You didn't think about execution context at all, really. And there is simplicity in that, but there's also limitations. So React Server Components are trying to take the best of both worlds, the best of both server execution and client execution, and giving you the flexibility to say where you think execution is best done for your user experience. And I love that it gives you that power. Like that you can make really, really great UIs that way. Because sometimes you want a very client heavy experience, like for a music player like Spotify, for instance. You kind of want that whole thing to be client side because you're constantly interacting with it. You need to be able to replace portions of the page or the whole page without stopping the music playing. So you can never do a full page refresh. Things like that are not possible or very challenging to do with a fully server side model. So with React Server Components, you can carve out different parts of your application and say, this part is going to be heavily server side because it's mostly statically delivered content that doesn't need to change. The user is not changing stuff all the time. And these other parts are very highly dynamic because maybe once you log in, then you want a very dynamic admin panel that you're changing lots of stuff all the time. And that makes more sense to be in the client because it can be very responsive. Because all the code is executing on the client. So it really is about your use case and choosing the technology to best fit your use case. React Server Components are sort of codifying that and saying, here's a common way that everyone can do this to give you that reusability across companies and projects. And with the new release of Redwood.js, so what other plans apart from the React Server Components, what other aspects are changing or improving? So that's a big part of it. But we also have things like real time GraphQL that are coming in. Those are actually in the current version 6 release. You can start playing with those already. So real time. So you can do GraphQL subscriptions and you can do live queries, which is a similar technology but slightly different depending on what use case you're going for. So those are coming in. We also have some really great sort of developer time diagnostics that we're working on. We have with a product called Studio. So Redwood Studio is going to be an application that you run alongside your Redwood.js application as you're building it. And we instrument the framework with open telemetry. And then you can point your Redwood Studio at your application and say, give me the stats of my application. So let's say you have a SQL query that you want to inspect. And because if you're using Prisma, it can be a little challenging to get and see like what is the actual SQL that's executing and how many queries are being generated for a specific Prisma statement that you execute. So Studio allows you to introspect that and see a request and everything that goes into that request and the timing and dig into what the SQL queries were and how long each of those took to execute. So everything that's happening server side, you'll be able to introspect with Studio. So it's like a new relic, for instance, you know, one of these observability platforms. But you have it during development very easily and completely for free. So there's things like this that we're doing that really make the platform much more sophisticated than you would expect a framework to be. Would it be end-to-end? So for example, from the API call or the GraphQL call that I'm executing, could I track it with Studio all the way down to the database? If, for example, I happen to have a bottleneck which not necessarily comes from the database, it might come from the business logic. Yeah, oh yeah, everywhere in the stack. It's all instrumented with open telemetry. So every part of everything that we can wrap in open telemetry. So once you get into your specific code, then you'll have to add some open telemetry stuff into your own business logic if you want to be able to see sort of deeper within the business logic that you're writing. But automatically at the sort of resolver, if you're using the GraphQL stuff, at the resolver level will give you that information and everything sort of below into when it goes back into the framework via sort of Prisma or other things. And could you speak a little bit more about the GraphQL, about the real-time updates that you said in the live queries? How does it work? Is it mostly to replace, for example, the use of sockets, possibly for an application that has to run in real-time? Yeah, so it doesn't use web sockets. It uses... I didn't implement this. There's the other technology like server-sent events, something of that nature. I'm sorry, I don't remember the specific name of it, but it's sort of the HTML, the HTTP way to do that. So it keeps a socket open and it sends events over that stream. So you need something that is a persistent server. So this is where we get away from serverless. And their lambdas are getting to the point where you'll be able to do more of these things soon, I think. Honestly, lambdas haven't evolved as much and improved as much as I thought they would when we started the project. I really thought that lambda would improve and evolve much more quickly. Oh, server-sent events, I think is the name of that technology. So you need something that looks like a server, right? So we're doing... and React Server Components obviously need some kind of a server to execute the server components. So a lot of the new versions of Redwood are leaning more towards dedicated server deployments, though we will still make them work on Netlify and Vercell. Obviously, Vercell, the only place that you can really do React Server Components today in a real way is via Next and deployed to Vercell. So obviously you can do it. That's all serverless. So obviously it can be done, right? They just are using serverless functions to act as the server part of that. So we need to build the right adapters to make it work in serverless environments, which we will do. But we're not optimized for that anymore. In the beginning, we really were. We were very optimized for Jamstack and serverless. But now we find that most people choose to deploy onto serverful environments, things like Render or Fly.io, AWS directly, because of the performance issues. You don't worry about cold starts. You don't worry about the costs. Costs can be unpredictable with serverless platforms. So we see a lot of people choosing either something that's containerized or just sort of bare metal. We have a deployment strategy called bare metal where it's just like, hey, get an EC2 server and go for it, right? Like do everything yourself. So you've seen with Redwood from the start, you optimized for the serverless. And now you're seeing a move of the community as well, the applications more into the serverful. And this is to both keep the persistence for the GraphQL and to avoid any additional issues with server-side rendering. I was wondering... Yeah, I mean, it's been that way for a while. This transition happened like a year and a half ago, really. And was it mostly a thing led by the community? So I was wondering, how do you choose what technology is RedwoodJS made of? And how do you work with your open source community at the same time? Do the community have any input on that? Yeah, absolutely. The community is one of the primary pillars of RedwoodJS from the very beginning. I wanted it to be a first class open source project. And a huge part of that is how we treat collaborators, what kind of community we're creating. So I thought a lot about how can we make the best open source community that we can? And so really inviting people to contribute and all of the core members came in through just starting to contribute. And I fund a number of them to work on it full time because it's open source. There's no corporate entity behind it. I just fund that myself because I like it being a pure open source project that's not affiliated with a commercial entity right now. I like the freedom that that gives the project. And so we have a Discord channel. We have a discourse forum, very active on both. We do a lot of community events from town halls to a conference. We're about to throw our first conference in September. So I could speak to that for a few minutes that regards our community. So this is September 26 through 29. It's going to be in Oregon, Southern Oregon, United States. It's going to be a four-day conference, but two of those days are the main talks. And then there's sort of an optional workshop day on the front end. And there's an optional sort of having fun and doing things out in nature or doing crafts on that fourth day or just hanging out with the other people at the conference. It's going to be awesome. It's going to be about Redwood JS, but really it's much broader than that. It's about entrepreneurship, security, design, everything in and around building web applications. You can go learn more about it at RedwoodJSconf. So you have an open source community, but also you're planning to do your first, I think it's the first conference in Oregon. And could you speak a little bit more about that? Yes. So we're holding our very first in-person conference. It's going to be September 26 through 29th this year, 2023, in Southern Oregon, United States. This is going to be a four-day conference. The first day is an optional workshop day. The next two days are going to be where the talks are. And then there's a fourth optional day for doing fun things around that location. This is in Grants Pass, Oregon. It's beautiful. There's redwood trees there if you want to come see some redwoods or do crafts or just hang out. And this conference is really about more than just Redwood JS. Like that's the reason that we're putting the conference on. But it's really to talk about the future of React and React Server components. And I'll talk, I'll give a keynote where I talk specifically about Redwood JS and how we're using React Server components and where we're at and how you can use them and experiment with them at that point. But it's really about everything around building a web application today. So security, design, performance, even how to build a company. We'll have talks about raising money, et cetera. Business people be there. So everything that you might need to become an entrepreneur and really be successful at building a web application. That's what this conference is about. We've designed it to be fairly intimate. So it's a smaller conference. My favorite conferences that I've ever been to have been in the order of a few hundred people in a location where you can really spend time getting to know each other. That to me is the real value of a conference. The people, the people that you meet there, the conversations that you have. And this was such a big part of my experience growing up in the Ruby community was going to these small conferences. So this is what we're trying to replicate with this conference. So you can go to redwoodjsconf.com and find out more information there. I'd love to see you there. And we'll also put the link into in the description of the of the actual podcast to make sure that you can just click through. And for people that won't be able to attend physically, but would still like to tune in online, would there be any option to view the talk that happened? Yes, absolutely. So you can you can you can purchase online tickets at any time and watch the content being streamed. Excellent. And coming back a little bit into the community part and into the projects that are that are currently using Redwoodjs. I was wondering, do you have any favorite projects or any specifically interesting projects that you would like to mention that evolved into startups and they are using Redwoodjs? And what do they do? Yeah. So one of the co-founders of Redwoodjs, Peter Pistorius, who I worked with at Chatterbug and has been with me on the Redwoodjs journey since the very, very beginning. He founded a startup called Snaplet that he's been doing for the last couple of years, which is built with Redwoodjs and is really amazing. So Snaplet is a way to use. Well, let me let me present the problem to you. So you're building a web application and you make it you put it to production. You have a bunch of people using it and they're all putting their data into the database. But you're still developing it locally. And when you're debugging things, especially, it's really nice to have some production data to do that because like replicating a database that looks like anything useful or anything that is going to help you fix a bug or build a new feature. All of that's in the production database. And so you really want to copy that production database into your local database. But that's a very bad idea, obviously, right? Like security issues are plentiful privacy issues in doing that. So it is definitely not best practice to do that. So Snaplet allows you to create a subset of your database and then anonymize it. So replace any sort of personally identifiable information. Replace that with anonymized data so that you can take a smaller subset of your potentially very large production database and then use that locally to test against, to work against. So snaplet.dev is the website there and they use Redwood JS. So that's one of my favorites. There's a startup studio called Fractal. And there's a bunch of startups, like a dozen or more startups that have come out of that, that all use Redwood JS doing vertical SaaS. So things like there's one called Leftlane. They've been using Redwood JS heavily and growing quickly. They build software for used car dealerships to manage their inventory and then manage people applying for credit and sort of doing the financial side of it. I think that's really cool. Like there's so many opportunities to build SaaS applications in places where modern technology has not yet really helped them out sufficiently. So the tons of these vertical SaaS cases. Or another one, a different place in the UK called Naus is helping people manage their household billings and then kind of keep track of like electricity usage and other things in the UK market and giving you tips for how to manage that better. They've raised something like 10 million pounds or something for that. So overall, we like to track startups that are using Redwood JS and really bring them into the open source ecosystem and help them out. We have a private channel where we get together with the startup founders once a month and try to help them out as much as we can from our past experiences as entrepreneurs within the community. And so far, companies that use Redwood JS, so companies that are building with Redwood JS overall have raised something like $70 million in funding. So we like to keep track of that number just as a bellwether of how many startups are using Redwood JS. And of course, that doesn't represent all of them and probably we're a little behind on some of the fundraising amounts. But these companies choosing and believing in Redwood JS is really important to us. We want to really help them as much as we can. So this is another reason maybe to choose Redwood is that you get access to this whole startup ecosystem of people that can help you out along your way in that admittedly very challenging journey. And as a developer, if I'm using Redwood JS, I have just built my site project and I'm trying to turn it into a startup to be featured or, for example, to connect with the community. What is the easiest way to join? Is it just to join the Discord channel or on GitHub? Or do you have any preferred way of bringing new people? I mean, Discord is great. Obviously, we love any interactions on GitHub if you're from submitting an issue saying that you have a problem with something or, well, we especially love pull requests. But any of the community channels, whether it's Twitter or X, what do we call it now? I don't even know. Is it for real though? Or is it just is it going to be a joke? This is going to stay. But I've seen already. So if you do x.com slash your username, I think then it redirects. No, if you do Twitter, they redirect you to X. I think if you do X, it redirects you back to the other one. Who could even know? Anyway, on that platform, you can find us. Redwood JS. And but I mean, any of them just reach out and say, hey, I'm building with Redwood. I would love to I would love to chat. And, you know, if you're building a start like a real startup, then we'd love to get you into the community. And any of the ways that you can reach us are viable. And could you speak a little bit more about the team that works on Redwood JS? How do you all work together? Because it's an open source project, but there are some people that work full time. And I was wondering what's the dynamics? What kind of mode do you work in? Yeah, so we work in a very open source fashion. So we're distributed all over the place. We've got some people here in California. We've got people in the UK, Scotland. We've got people in one of our guys is in Thailand. So it's really it's all over the place. But we all came together by contributing. Every everyone that's come to join the core team came in through actually contributing. And then some of those people I've hired on full time to work on Redwood JS. So I think it was a year and a half or so ago we announced the Redwood JS 1.0 release saying we're production ready. You should use Redwood JS. At that time, I committed to spending one million dollars a year on funding the development of Redwood JS. So that's that's around what we're running now. So I employ some people to work on it. And so that represents the core team. And that's really just selecting the most committed developers, the best and most committed developers that we found around the Redwood JS ecosystem coming in from just authoring pull requests, elevated them to core membership, and then I pay them so that they can spend their time doing that. And we can make a really sophisticated system without having to compromise our open source values with a commercial entity. I mean, I would love to make money with Redwood someday, but it's not my it's not my top priority right now. More priority to me is building the most amazing web framework that we can. And I think with the Redwood or sorry with React Server components, the future for that is even better. So one of the challenges is that we kind of started we started with with a very sophisticated model with a very sophisticated framework. And we were trying to figure out how to make it more accessible to people that are just experimenting. Right. We started up market and where something like Next.js started kind of down market like super simple, very small component of what you're trying to do like this rendering kind of framework. And then and then have gone up market become more sophisticated trying to reach broader markets. Like we put together this very sort of integrated full stack framework and up market. And now we're trying to figure out how to come down market and make it more appealing to people that are just doing a weekend hackathon or something. In those instances, building out a full GraphQL API, even as easy as we make it, feels like a lot. And so React Server components allow us to give people the option of not needing to use GraphQL. So once we have once we release a bighorn release, a release with React Server components, then you'll be able to choose to not use GraphQL at all. And so you might start using just React Server components and doing your data fetching server side. You're reaching directly for Prisma directly into your database, fetching your data, and then that gets rendered and sent out to your client. You don't need to use GraphQL to do your fetching anymore. And you'll be able to do that very, very quickly. But because we have such great GraphQL support, if later on you want to add a mobile client, an iOS app or an Android app or something, and you want to use GraphQL for that. Well, we have amazing GraphQL support, fully integrated, that you can now start building out your GraphQL API back end. But you probably at that point have dedicated GraphQL people and know how to build and manage a GraphQL API with all of the performance and security challenges that can come along with that. And then once you have your GraphQL API, like I was saying before, your friend and people start to want to consume the GraphQL API. So making it really easy then to consume the GraphQL API from your React Server components. So you're still doing your data fetching server side for the most part. But you're doing it via GraphQL server side, which is maybe a little weird, but also kind of awesome. Because with GraphQL, you're just saying, here's the data I want. You're not having to worry about how to pose this, you know, how to construct a Prisma query to do that in a performant way. All of the performance stuff has been handled for you already on the GraphQL API. Side, and you just say, here's the data I want. You can be very flexible about that. And in that scenario, you're not even having to worry about security as much because you just don't make your GraphQL API public if you don't want to. I mean, you can't if you're if you built it because you're doing a mobile client, then probably it already is. But you wouldn't have to. And so there's this to me this beautiful evolution using Redwood where you can get started very easily once we have React Server components. And then grow into GraphQL as a more sophisticated API that allows you to consume it both from a mobile client or any kind of client and then also in your own front end. Just also a nice way for startups with limited resources to grow gradually and kind of put a more progressively growing into the GraphQL. Yep. And that's really everything around building a web app is you want to be iterative. You want to do things incrementally, making huge commitments upfront tends to slow you down. And so that's that's exactly where we're trying to go or completely kill the product. So yes, as it may be. How do you imagine the future of software engineering within the next 10 years? And what part of it are the most excited about? That's always a challenging question. I think obviously we have to mention AI in that discussion. Things like chat, GPT and co-pilot have already changed how we write code. I use it extensively when I'm especially when I'm working on my electronics project where I'm writing primarily C and I don't write a lot of C normally. And so having chat GPT there to say, hey, what's the idiomatic way to like do this thing or how should I deal with memory in this instance where this function is allocating memory and then needs to return it? Like, what is the normal way to to then free that up? Like, who's responsible for that? Like these questions that you can Google, but you end up having to go through like five or six articles before you find something that really is gets at what you want. Chat GPT makes that really easy to get too much quicker. That's sort of level one of AI. I mean, where are we going to get to? Like, how many years will it be before we're not really writing low level code anymore? I think it's really hard to say. But over a 10 year span, for instance, I think we probably get much more descriptive about what we're doing and we leave some of the details to AI systems that are very good at building those out because there's so much example code to do that. We'll probably have frameworks that are specifically designed for that, where instead of writing the code itself, you're writing more of a descriptive language. So you kind of have a something that looks more like prose, but it's probably a little bit more structured than just like say what you want. And that you could use that to start with and then an AI system would sort of generate that. And then at that point, you can have a conversation with it and say, no, I actually, you know, want to change this thing in this way. It essentially, I guess, becomes like a programmer that you're standing behind pointing at things on the screen saying, no, what if this form had this other field? And, you know, it's really hard, though, because we as developers, like everything that we do is very specific. Right. Like I need this field in this form to go into this column in this database with this transformation so that I can do these things with it in the future. And I think it could become very frustrating to try to do that with AI systems where you're just spending the same amount of time and effort to do things. You're just speaking in English instead of code. And I don't know that that's necessarily an improvement. Because you still have to describe each single piece very specifically, I mean, so you just spend time hanging over it. Right. If you want to be that specific, like that's kind of what code is. It's just a very formalized version of English that allows us to be as specific as we want it to be, really, at the end of the day. Right. So I'm not sure exactly where that goes. And I think it's very difficult to predict. But it will obviously change the way that we write code, the way that we build web applications. I think the harder thing to do is to create something really new. Like how would you build a web framework? I'm trying to think of like, does this replace me as a person building a web framework? Like how do we get an AI to do that? Like that's really about bringing the creativity and the curation of selecting specific technologies and things like that. I mean, at some point maybe it doesn't matter because the AI is doing all of the choosing of all the technology and you don't even care what language it's writing in anymore. But I'm not sure. I think there will be a lot of frustrating times between now and that sort of vision of the future where you really just, you know, the Star Trek vision of the future. Where you're just like, hey, computer, I need this thing. And it's like, all right, I got you. And you're happy with the outcome. I think we're quite a ways from that. I think in the meantime, we just become happier, more efficient developers because we have better ways to answer our questions. Do you think that it might potentially make the future generations of developers more incompetent because they will just go and ask for each single of the things that they don't know and receive pieces of code that might be too complicated to understand, for example? Well, sure. But in the same way that we today are more incompetent at machine code level things because we don't, you know, we don't write in assembly anymore. Right. And the things that we do at the level that we're writing code are probably much less efficient than if you were to hand code them in assembly. But the question is, does it matter? Have computers become fast enough that we can get done what we want to get done much faster, but at the expense of some performance? I think that's the real question. I think obviously we probably become less good at understanding the very deep down bits of computers. Not everyone, obviously, but the everyday programmer. But that's been happening for years. It's just a further evolution of the abstractions that we built. The level of abstraction, yeah. Right. And you know, no code tools are kind of the same way. Like those tools can be amazing. Things like Retool and any of the no code kinds of web flow. All of those are basically saying, you know what you want your thing to look like and behave like. And so just tell us that and then we'll code it up for you underneath because like you don't actually need to know that. Does that make you more incompetent at programming? Certainly. You don't even need to know how to program to use those tools. You're like completely incompetent at programming. But guess what? You're solving your problem faster than someone who's coding it from scratch. So who's the better programmer at the end of the day? Right. Really, at the end of the day, programming, writing code is a means to an end in my book. I mean, I love programming. I love the act of programming, but I only program, I only write code really to solve problems, to build solutions. So to me, that's the outcome that it should be optimized for is building solutions. Whether we write code, whether we write assembly or we write C or we write Ruby or we write, you know, web flow. Like to me, it doesn't really matter. What matters is, are we building something valuable that makes people's lives better? And as the last question, as a request for advice, I was wondering, do you have any advice to developers who are currently trying to turn a side project into a startup, into a successful one? Yeah, I'd say you first have to try. You have to decide that you want to do that, that you need, you know, and then you need to learn what you need to do. And it's not always programming. Sometimes it's marketing or sales or something, going to conferences, talking to people, finding customers. That is the sometimes disappointing answer for programmers because we often become programmers because we don't want to go be a salesperson. But if you want to build something valuable, a product that people love to use that solves a problem for them, you have to do all the parts of a business, really. Yeah, you have to build a thing, but you have to get people to know about the thing. You have to get, you have to solve their problems for them when they start using the thing and it doesn't work the way that they intended it to work for them. You have to become a customer service person. So you have to do all of those things. So I just say the right way to be successful at building a startup is to be willing to do whatever it takes to solve the customer's problem and figure and be happy doing that. That's the right kind of attitude. That's the right kind of person to be successful with a startup. Someone who's after it to solve problems and create value, not just to be a programmer. And use the right web framework. And use RedwoodJS, of course. Exactly. Cool. Awesome. Thank you so much, Tom, for your time. It was great talking with you. Absolutely. Thanks so much."}, "podcast_summary": "You're welcome! It was my pleasure to assist you. If you have any more questions, feel free to ask.", "podcast_guest": "Tom Preston Warner", "podcast_highlights": "You're welcome. I'm glad I could help. If you have any more questions, feel free to ask."}